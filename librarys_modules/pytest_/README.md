# По книге Briann Okken - Python Testing with pytest
 **[`Запуск тестов`](https://github.com/Harlok13/Study/blob/main/librarys_modules/pytest_/README.md#Запуск-тестов:)**
 **[`Названия для тестов`](https://github.com/Harlok13/Study/blob/main/librarys_modules/pytest_/README.md#Какими-должны-быть-названия,-чтобы-pytest-обнаруживал-тесты:)**

## Запуск тестов:
Весь путь в примерах указывается относительно текущего местоположения\
Командой в терминале `pytest`, где указывается директория, 
откуда производится запуск тестов или перечисляются файлы, содержащие тесты.\
`pytest .` запустит все тесты.\
Можно указать только отдельные файлы для запуска:\
`pytest tests` или `pytest tests/test_calculator.py tests/tasks/test_three.py`\
При указании флага `-v` будет показана дополнительная информация.

Часть выполнения pytest, где pytest проходит и находит, какие тесты запускать,
называется test discovery (тестовым обнаружением)
#### Выполнение только одного теста:
Указать файл напрямую и добавить `::test_name`\
`$ pytest -v tasks/test_four.py::test_asdict`

## Какими должны быть названия, чтобы pytest обнаруживал тесты:
- Тестовые файлы должны быть названы `test_<something>.py` или `<something>_test.py`.
- Методы и функции тестирования должны быть названы `test_<something>`.
- Тестовые классы должны быть названы `Test<Something>`.

Чтобы изменить эти правила, нужно вносить правки в конфигурации

## Результат запуска одного файла
```
$ cd /path/to/code/ch1/tasks
$ pytest test_three.py
================= test session starts ==================
platform darwin -- Python 3.6.2, pytest-3.2.1, py-1.4.34, pluggy-0.4.0
rootdir: /path/to/code/ch1/tasks, inifile:
collected 2 items
test_three.py ..
=============== 2 passed in 0.01 seconds ===============
```
Платформа darwin —  Mac. На компьютере с ОС Windows
платформа отличается.\
Далее перечислены версии Python и `pytest`, а также зависимости от
пакетов `pytest`.\
И `py`, и `pluggy` — это пакеты, разработанные командой `pytest`, чтобы
помочь с реализацией pytest.

#### rootdir: /path/to/code/ch1/tasks, inifile:
`rootdir` — это самый верхний общий каталог для всех каталогов
в которых ищется тестовый код.\
В `inifile` (здесь пустой) перечислены используемые файлы 
конфигурации.\
Конфигурационными файлами могут быть `pytest.ini`,
`tox.ini` или `setup.cfg`.

#### collected 2 items
Это две тестовые функции в файле.

#### test_three.py ..
`test_three.py` показывает тестируемый файл. Для каждого тестового
файла есть одна строка. Две точки означают, что тесты пройдены — по
одной точке для каждой тестовой функции или метода. Точки
предназначены только для прохождения тестов. `Failures` (сбоев),
`errors` (ошибок), `skips` (пропусков), `xfails`, и `xpasses` обозначаются 
с `F`, `E`, `s`, `x`, и `Х`, соответственно. Если вы хотите видеть больше
точек для прохождения тестов, используйте опцию `-v` или `--verbose`.

#### == 2 passed in 0.01 seconds ==
Эта строка относится к числу пройденных тестов и времени, затраченному
на весь сеанс тестирования. При наличии непроходных тестов здесь
также будет указан номер каждой категории.

#### Возможные результаты тестовой функции:
- PASSED (.): Тест выполнен успешно.
- FAILED (F): Тест не выполнен успешно (или XPASS + strict).
- SKIPPED (s): Тест был пропущен. Вы можете заставить pytest 
пропустить тест, используя декораторы `@pytest.mark.skip()` или
`pytest.mark.skipif()`
- xfail (x): Тест не должен был пройти, был запущен и провалился.
Вы можете принудительно указать pytest, что тест должен
завершиться неудачей, используя декоратор `@pytest.mark.xfail()`
- XPASS (X): Тест не должен был пройти, был запущен и прошел!..
- ERROR (E): Исключение произошло за пределами функции тестирования,
либо в фикстуре

## Использование опций:
Ознакомиться с полным списком опций можно командой `pytest --help`

#### --collect-only
Параметр `--collect-only` показывает, какие тесты будут выполняться
с заданными параметрами и конфигурацией. 
Параметр `--collect-only` полезен для проверки правильности выбора 
других опций, которые выбирают тесты перед запуском тестов

#### -k EXPRESSION
Параметр `-k` позволяет использовать выражение для определения
функций тестирования.
Её можно использовать как ярлык для запуска отдельного теста,
если имя уникально, или запустить набора тестов, которые имеют
общий префикс или суффикс в их именах. Предположим, вы хотите 
запустить тесты `test_asdict()` и `test_defaults()`. Вы можете
проверить фильтр с помощью: `--collect-only`
```
$ cd /path/to/code/ch1
$ pytest -k "asdict or defaults" --collect-only

=================== test session starts ===================
collected 6 items
<Module 'tasks/test_four.py'>
  <Function 'test_asdict'>
<Module 'tasks/test_three.py'>
  <Function 'test_defaults'>

=================== 4 tests deselected ====================
============== 4 deselected in 0.03 seconds ===============
```
Теперь можно запустить их, удалив `--collect-only`
```
$ pytest -k "asdict or defaults"
=================== test session starts ===================
collected 6 items
tasks/test_four.py .
tasks/test_three.py .

=================== 4 tests deselected ====================
========= 2 passed, 4 deselected in 0.03 seconds ==========
```
Просто точки. Так значит они прошли. Но были ли они правильными
тестами? Один из способов узнать — использовать `-v` или `--verbose`:
```
$ pytest -v -k "asdict or defaults"

=================== test session starts ===================
collected 6 items
tasks/test_four.py::test_asdict PASSED
tasks/test_three.py::test_defaults PASSED

=================== 4 tests deselected ====================
========= 2 passed, 4 deselected in 0.02 seconds ==========
```
#### -m MARKEXPR
Маркеры-один из лучших способов пометить подмножество тестовых
функций для совместного запуска. В качестве примера, один из 
способов запустить `test_replace()` и `test_member_access()`, даже
если они находятся в отдельных файлах, это пометить их. Можно
использовать любое имя маркера. Допустим, вы хотите использовать
`run_these_please`. Отметим тесты, используя декоратор
`@pytest.mark.run_these_please`, вот так:
```python
import pytest
...
@pytest.mark.run_these_please
def test_member_access():
...
```
Теперь то же самое для `test_replace()`. Затем вы можете запустить
все тесты с тем же маркером с помощью `pytest -m run_these_please`:
```
$ cd /path/to/code/ch1/tasks
$ pytest -v -m run_these_please

================== test session starts ===================
collected 4 items
test_four.py::test_replace PASSED
test_three.py::test_member_access PASSED

=================== 2 tests deselected ===================
========= 2 passed, 2 deselected in 0.02 seconds =========
```
Выражение маркера не обязательно должно быть одним маркером. 
Вы можете использовать такие варианты, как -m "mark1 and mark2"
для тестов с обоими маркерами, -m "mark1 and not mark2" для тестов,
которые имеют метку 1, но не метку 2, -m "mark1 or mark2" для тестов
с одним из и т. д.

#### -x, --exitfirst

