### Алекс Глозман

```
d = [1, 2, [True, False], ["Москва", "Уфа", [100, 101], ['True', [-2, -1]]], 7.89]

get_line_list = f = lambda d, a=[]:\
        f(d[1:], f(d[0], a) if type(d[0]) is list else a + [d[0]]) if d else a
```
___
ну это я ещё пощадил читателя :), ведь мог же выложить вот такую версию:

```
get_line_list = f = lambda d, a=[]:\
        d and f(d[1:], type(d[0]) is list and f(d[0], a) or a + [d[0]]) or a
```
В качестве отправной точки можно взять соседнее решение и поставить себе задачу 
упаковать все в одну строку. Препятствием для этого очевидно является цикл `for` -
его подменяем срезами: делим список на первый элемент и все остальное. Логику
алгоритма привязываем непосредственно ко второму аргументу функции, подобным 
приемом часто пользуются при создании так называемой хвостовой рекурсии. Платой
за такое сокращение является появление дополнительного рекурсивного вызова 
в аргументе функции, что уже не характерно для хвостовой рекурсии. Чтобы не пользоваться
длинным именем функции, вводим синоним `f`. Когда список `d` становится пустым - возвращаем
уже сформированный одномерный список `a` - это базовый случай рекурсии.
___
### Andrew democrat

@Алекс_Глозман, привет. по факту генератор

```[get_line_list(el, a) if type(el) == list else a.append(el) for el in d]```

тут все равно быстрее?
___
### Алекс Глозман

@andrew_democrat, думаю да, в этом варианте нет доп. рекурсивного вызова :).
