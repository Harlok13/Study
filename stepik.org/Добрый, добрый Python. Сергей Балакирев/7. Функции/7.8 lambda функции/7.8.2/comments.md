### Алекс Глозман

```get_div = lambda a, b: b and a / b or None```
___
 к сожалению, это решение не учитывает одну ситуацию. В случае если `a = 0`,
 то вернется не число `0` а `None`!  C другой стороны, может кто-то прочтет этот 
 комментарий и задумается над особенностями вычисления логических операторов в 
 языке Python. Короче, на таких логических конструкциях можно легко погореть
 как это случилось со мной). Возможно, положение может исправить такой вариант решения

`get_div = lambda a, b: (b or None) and a / b`

но вообще в голове у меня все время сидит мысль о том, что значение `None` возвращается
любой функцией по умолчанию, вот если бы можно было сделать так, чтобы в теле лямбда функции
рассматривался бы лишь один вариант `b != 0`?
___
в Python

>результатом логического выражения будет значение подвыражения, которое проверялось последним 
>в процессе ленивого вычисления.

Причем подвыражение может быть любым: логическим или арифметическим или даже сложением строк
и результат будет равен значению этого подвыражения, т.е. он необязательно будет булевым 
значением!

>например `(b or None)`, почему функция выбирает `None`, если `b == 0`, а не ноль?

Если `b == 0` значит в булевом эквиваленте это будет `False`. В этом случае, по правилам 
ленивого вычисления, оператор `or` должен проверить свой операнд справа (это `None`). `None`
в булевом эквиваленте всегда даёт `False`, значит все выражение в круглых скобочках дает
`False: False or False = False`. Дальше в игру вступает логический оператор `and`. Но, по
правилам ленивого выполнения, он уже не будет проверять свой правый операнд, потому что
независимо от значения последнего, все выражение все равно будет `False`, так как его левый 
операнд уже - `False`. Далее идет самое необычное, значением всего выражения будет не 
вычисленное булево значение (`False`), как это происходит в дргуих ЯП, а это будет значение
последнего проверенного подвыражения! Этим подвыражением было `None`, значит оно и вернется
в качестве результата. Точно так же, при ненулевом значении `b`, булево значение в круглых 
скобочках будет `True`, тогда оператор `and` вынужден будет проверит свой правый операнд.
Тут уже даже не важно каким будет результат деления `a / b` и даст ли он `False` или `True`!
Важно лишь то, что деление выполнялось последним и значит его значение и будет возвращено!
Иная картина была в первом решении, там было действительно важно каким будет результат деления
`a / b`, потому что в случае нулевого значения выполнилось бы `or None`.
