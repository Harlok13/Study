### Алекс Глозман

в инструкции

`print(n == 1 and 1 or get_rec_N(n - 1) is None and n)`
заложена логика следующего условного оператора:

    if n == 1:
        print(1)
    else:
        get_rec_N(n - 1)
        print(n)
Используются особенности вычисления условных выражений 
в Python. Значение логического выражения не обязательно 
будет булевым как в других ЯП, а это будет значение операнда 
вычисленного последним в процессе ленивого выполнения всего 
выражения. Как известно, в рамках ленивого вычисления логич. 
выражения, оператор `and` приступит к вычислению второго операнда
только если первый дает `True` в булевом эквиваленте. Оператор
`or` выполнит второй операнд только если первый окажется `False` 
в булевом эквиваленте. Таким образом, логические значения 
операндов вычисляются только для определения порядка ленивого 
выполнения, а в качестве значения выражения берется значение 
операнда согласно его типу. Выражение `get_rec_N(n - 1)` is None, 
если до него конечно дойдет очередь, будет всегда True, потому 
что все функции возвращают `None` по умолчанию. Идея в том, чтобы
вызвать функцию `get_rec_N(n - 1)` перед тем как напечатается 
значение `n`.
