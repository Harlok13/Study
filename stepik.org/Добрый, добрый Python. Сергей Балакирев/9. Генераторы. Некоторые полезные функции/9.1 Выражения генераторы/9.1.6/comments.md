### Алекс Глозман

```
cities = ["Москва", "Ульяновск", "Самара", "Уфа", "Омск", "Тула"]
gen = (cities[i % len(cities)] for i in range(1_000_001))
print(*(next(gen) for _ in range(20)))
```
Во-первых, с лишней единицей в конце числа 1_000_001 я погорячился), 
во-вторых, не очень эффективно выполнять  многократно оператор %. 
Ниже следует бенчмарк сравнения времени выполнения 5 вариантов решения, 
два заключительных (и самых быстрых) с использованием функций библиотеки
itertools. Ваше решение тестируется вторым. Идея 3-го и 4-го решения 
заключается в том чтобы заранее узнать остаток от деления 1_000_000 на 
кол-во городов в списке и построить генератор, так чтобы он в конце, если
понадобится, дополнял нехватающие города до 1_000_000. Понятно, что
генерировать последовательность ровно до 1_000_000 не имеет практического 
смысла, с таким же успехом можно было сгенерировать бесконечную последовательность,
но зато такое решение соответствует условию задачи

import timeit

'''
    Basic framework to test code snippets
'''
general test setup
```
NUMBER = 10_000  #  1000 повторений для выбора наилучшего на каждом прогоне
REPEAT = 5       #  5 прогонов
```

function to run the test
```
def run_test(code_setup, code_to_test, number=NUMBER, repeat=REPEAT, cnt=[0]):
    cnt[0] += 1  # автоматическая нумерация тестов
    elapsed_time = timeit.repeat(stmt=code_to_test, setup=code_setup, number=1000, repeat=5)
    average = sum(elapsed_time) / len(elapsed_time)
    rounded_results = [round(t, 6) for t in elapsed_time]
    print(f'test {cnt[0]}, average: {average:.6f}, from {repeat} repeats: {rounded_results}')
```

code_setup = '''
```
cities = ["Москва", "Ульяновск", "Самара", "Уфа", "Омск", "Тула"]
n = 10_000  #  кол-во элементов на выводе
```
'''

put code snippets here

code_to_test1 = '''
тестируемый код
```
gen = (cities[i % len(cities)] for i in range(1_000_000))
lst = [next(gen) for _ in range(n)]
```
'''

code_to_test2 = '''
```
gen = (cities[j] for i in range(1_000_000) for j in range(len(cities)))
lst = [next(gen) for _ in range(n)]
```
'''

code_to_test3 = '''
тестируемый код
```
def cycle_gen(lst, reps):
    c, r = divmod(reps, len(lst))
    for _ in range(c):
        for e in lst:
            yield c
    for i in range(r):
        yield lst[i]

gen = cycle_gen(cities, 1_000_000)
lst = [next(gen) for _ in range(n)]
'''

code_to_test4 = '''
from itertools import chain, repeat
c, r = divmod(1_000_000, len(cities))
gen = chain(repeat(cities, c), (lst[i] for i in range(r)))
lst = [next(gen) for _ in range(n)]
'''

code_to_test5 = '''
# тестируемый код
from itertools import cycle
gen = cycle(cities)
lst = [next(gen) for _ in range(n)]
'''

run_test(code_setup, code_to_test1)
run_test(code_setup, code_to_test2)
run_test(code_setup, code_to_test3)
run_test(code_setup, code_to_test4)
run_test(code_setup, code_to_test5)
```
результаты тестирования:
```
test 1, average: 2.447171, from 5 repeats: [2.470731, 2.387959, 2.384237, 2.576541, 2.416389]
test 2, average: 2.154100, from 5 repeats: [2.18275, 2.133566, 2.109458, 2.159408, 2.185321]
test 3, average: 1.603751, from 5 repeats: [1.642223, 1.677893, 1.543058, 1.603695, 1.551884]
test 4, average: 0.742631, from 5 repeats: [0.76674, 0.698937, 0.820289, 0.692451, 0.734738]
test 5, average: 0.701990, from 5 repeats: [0.76562, 0.688286, 0.692174, 0.680643, 0.683226]
```

взятие остатка от деления на некоторое число mm как бы "закольцовывает" значения в диапазоне [0..m-1][0..m−1]. В данной задаче, с помощью этого свойства, гарантируется, что индексы списка cities будут циклически изменятся в пределах допустимого диапазона [0..5][0..5], несмотря на то, что значение переменной цикла i все время возрастает. Интуитивно, взятие остатка от деления на число mm можно представить как многократное вычитание числа mm до тех пор пока результат не станет меньше mm. Это и будет остаток. Вот так и получается, что с увеличением значения переменой i значние выражения i % 6 изменяется циклически:

i:             0    1    2     3     4     5     6     7     8      9    10    11     12    13    14 ...

i % 6:      0    1    2     3     4     5     0     1     2     3      4       5       0       1      2 ...

Для наглядности, можно нарисовать своеобразный цифирблат часов, на котором нанесено по кругу только 6 делений 0, 1, 2, 3, 4, 5, расположенных на равном расстоянии. Если откладывать значения переменной i по часовой стрелке начиная с отметки 0, то проделав полный круг, отсчет опять начнется с нуля. Мы как бы вычли полный круг из значения переменной i и пошли на следующий круг :). Но почему бы не вычесть сразу все полные круги (длиной 6) из значения i, а то что останется отложить на циферблате. Это и будет остаток от деления. В математической форме, все это укладывается в основную теорему деления с остатком, которая гласит следующее:

Теорема: Для данного целого, отличного от нуля, числа mm , всякое целое число nn единственным образом представимо в виде частного qq и остатка rr:

n = mq + rn = mq + r, где 0 \le r \lt |m|0≤r<∣m∣

Следует отметить, что компьютерная арифметика иногда оступает от данной формулы, в частности от требования того, что остаток rr всегда обязан быть неотрицательным. Например, в языке Python знак остатка определяется знаком делителя, а для С-образных языков - знаком делимого. Эта ситуация объясняется тем, что точная компьютераная реализация целочисленного деления с остатком получается менее эффективной. Однако, такое положение приводит к нарушению некоторых математических тождеств и это факт следует учитывать на практике. Но это уже совсем другая история :).
