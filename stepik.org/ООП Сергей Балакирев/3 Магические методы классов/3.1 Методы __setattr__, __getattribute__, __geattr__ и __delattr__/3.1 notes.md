![](../../../../img/lookup_instance.png)

Допустим, мы имеем атрибут name в экземпляре my_obj класса TestClass.

class TestClass:
    def __init__(self, name):
        self.name = name

    def get_attr(self):
        return self.name


my_obj = TestClass("Python")
Начну с того, что из перечисленного, реально атрибут можно вызвать тремя способами:

Напрямую: my_obj.name - ищет атрибут в my_obj.__dict__.
Встроенная функция getattr(my_obj, "name", "Ошибка") - то же самое. Но, если атрибут не будет найден или у него нет значения, можно вернуть что-нибудь другое.
Самописный метод get_name() - обращение к атрибуту изнутри. Можно дописать в метод свои фишки, которые не влияют на имя самого атрибута, а только на значение.
Вызвать атрибут через my_obj.__getattribute__("name") тоже можно, но зачем?))

--- Сразу определимся с самым могущественным методом - магический метод __getattribute__(). Он вызывается автоматически, вне зависимости от вашего желания, когда идёт обращение к любому атрибуту объекта через любые другие способы, а в случае с самописным методом get_attr() магический метод сработает два раза - на сам get_attr() и на name. Менять магический метод следует крайне аккуратно и только в крайних случаях.

Пока нет защиты, т.е. атрибут name прописан без __, мы можем вызывать атрибут всеми тремя способами выше. Давайте добавим защиту.

class TestClass:
    def __init__(self, name):
        self.__name = name

    def get_attr(self):
        return self.__name

my_obj = TestClass("Python")
Пока всё хорошо, атрибуту успешно присвоено имя. Но теперь из вышеперечисленного работает только самописный метод get_name(), потому что в my_obj.__dict__ нет ни __name, ни name (Магия Python).

--- Геттеры @property и дескриптора данных, который мы рассматривали ранее, по сути работают одинаковым образом, т.к. @property - это частный случай дескриптора. В обоих случаях, они захватывают имя нашего атрибута и переделывают его в объект своего класса. Поэтому при любом способе обращения к name(они все опять работают), мы будем обращаться не к атрибуту, а к дескриптору, который уже и будет выдавать нам тот результат, который в нём прописан. В итоге составляя такую цепочку:

my_obj.name -- __getattribute__() -- name -- @property -- __name -- __getattribute__() -- __name -- Python
