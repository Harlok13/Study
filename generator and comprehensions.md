# (ps требует доработки и оформления)

1) все компсы и генэксп работают по принципу
[ВЫРАЖЕНИЕ/ПРЕОБРАЗОВАНИЕ for element in ИСТОЧНИК if УСЛОВИЕ]
читается это слева направо, что важно когда циклов больше 1.
2) принцип работы операций у листкомпс и генэксп одинаков, синтаксически различаются скобками
3) компсы (листкомпс, сеткомпс, дикткомпс) в результате своей работы формируют соответствующую коллекцию и занимают память
4) переменные созданные внутри компсов или генэкспа недоступны извне
5) генэксп вернет объект, а не коллекцию! при создании объекта он проверит источник, что может быть критично, если это какая то функция. Если источник не валидный то ошибка упадет при создании генератора, а не при попытке получить значение
6) генэксп ленивый, то есть ничего не делает и не занимает память пока не потребуется значение. Сгенерировав значение снова засыпает пока опять не попросят новое.
7) генэксп одноразовый, при исчерпании начинает бросать исключение, которое мы не увидим, если используем генератор в цикле for
8) генэксп может потенциально генерировать бесконечные последовательности, но он ничего не знает о порядке элементов или о их количестве (нет len)

Лично мое мнение -  если вам не нужна длина, слайсы, индексы, то нужно использовать генэскп, не только из-за экономии памяти, но и из-за ленивости, экономии процессорного времени.
Естественно важно помнить что даже pep-8 и дзен - это не закон, а рекомендации, наша конкретная реализация и подход должны диктоваться имеющимися условиями и решаемой задачей.

Полезные ссылки:
https://docs.python.org/3/tutorial/da...

https://docs.python.org/3/reference/e...

https://docs.python.org/3/howto/funct...

https://docs.python.org/3/whatsnew/2....

Генератор формирует объект, а не структуру данных
И он генерирует не коллекцию, а набор инструкций 
Так же он ленивый, пока не попросишь у него значение -
он ничего делать не будет и не будет занимать память 

И очень важно: генератор проверяет источник генератора при создании.
Если функция функция возвращает итерируемый объект, то генератор сначала
проверит, что это итерируемой объект, а потом просмотрит
и само тело функции. Это нужно учитывать, если функция
тратит много времени и ресурсов, в таком случае создание генератора 
будет ресурсозатратным

Генератор будет полезен при чтении больших логов и в отличие от
листкомп не будет занимать память

после использования генератора, он исчезает, использовать
повторно его нельзя и нужно будет создавать новый генератор

генератор - это итератор\
если перебирать его значения с помощью функции next, то в конце
он выкинет исключение  StopIteration\
а цикл for перехватывает StopIteration\
у генератора нельзя посчитать длину, потому что сам генератор не будет
знать сколько значений в нем хранится
у генератора нельзя получить значения по индексу

# Вывод

* переменные листкомпс недоступны извне
* читается слева направо
* для словаря обязательно указать КЛЮЧ:ЗНАЧЕНИЕ
* генератор вернет объект, а не коллекцию
* генератор ленивый, не выполняет действий и не занимает память пока не потребуется
* генератор проверяет источник при создании
* генератор одноразовый, если исчерпан бросает исключение StopIteration
* цикл for перехватывает исключение StopIteration
* использовать генексп, вместо компс, кроме случаев, когда нужна длина len или индексы
